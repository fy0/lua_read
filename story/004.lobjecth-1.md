
# lobject.h

## 1

```C
/*
** tags for Tagged Values have the following use of bits:
** bits 0-3: actual tag (a LUA_T* value)
** bits 4-5: variant bits
** bit 6: whether value is collectable
*/


/*
** LUA_TFUNCTION variants:
** 0 - Lua function
** 1 - light C function
** 2 - regular C function (closure)
*/

/* Variant tags for functions */
#define LUA_TLCL	(LUA_TFUNCTION | (0 << 4))  /* Lua closure */
#define LUA_TLCF	(LUA_TFUNCTION | (1 << 4))  /* light C function */
#define LUA_TCCL	(LUA_TFUNCTION | (2 << 4))  /* C closure */


/* Variant tags for strings */
#define LUA_TSHRSTR	(LUA_TSTRING | (0 << 4))  /* short strings */
#define LUA_TLNGSTR	(LUA_TSTRING | (1 << 4))  /* long strings */


/* Variant tags for numbers */
#define LUA_TNUMFLT	(LUA_TNUMBER | (0 << 4))  /* float numbers */
#define LUA_TNUMINT	(LUA_TNUMBER | (1 << 4))  /* integer numbers */

```

这个类型标记包含了不少信息。同一类型的数据也是有所区别的。


## 2

```C

/*
** Common type for all collectable objects
*/
typedef struct GCObject GCObject;


/*
** Common Header for all collectable objects (in macro form, to be
** included in other objects)
*/
#define CommonHeader	GCObject *next; lu_byte tt; lu_byte marked


/*
** Common type has only the common header
*/
struct GCObject {
  CommonHeader;
};
```

GCObject，发现是典型的单链表


## 3

随后是Value定义和一段辅助宏，应该都比较重要

首先是类型检查，后面是什么呢？按类型读取变量？

check_exp这个宏好奇怪，还可以这么玩耍？我真好奇前一个检查通不过的话会如何。

还有这里tt应该是代表type tag

然后先是get再是set么

再往后终于是一个重要发现：

```C
union Value {
  GCObject *gc;    /* collectable objects */
  void *p;         /* light userdata */
  int b;           /* booleans */
  lua_CFunction f; /* light C functions */
  lua_Integer i;   /* integer numbers */
  lua_Number n;    /* float numbers */
};
```

卧槽，原来受GC控制的对象天生就是被串起来的吗。

而且剩下几种都不受GC管？看来这并非是一个万物皆对象的语言啊，有些东西是特别的。

另外，str是GCObject，而数字和布尔几种却不是。


```C
typedef TValue *StkId;  /* index to stack elements */
```

这玩意貌似很重要的样子。



